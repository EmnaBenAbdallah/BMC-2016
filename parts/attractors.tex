%\subsection{Intuitive idea}

In the previous section we showed a method to enumerate all fixed points.
In the following, we focus on the more complex kind of minimal trap domains: attractors.
We describe here how to obtain the set of all attractors of a fixed size;
obtaining all attractors can be tackled by gradually increasing this size.

The computational method to enumerate all attractors of size $N$ in a PH model falls into three stages:
\begin{enumerate}
  \item Enumerating all sub-State Transition Graphs (sub-STGs)
    with $N$ transitions,
  \item Filtering out all of these sub-STG that are not cyclic,
  \item Checking, for each state of the remaining cycles,
    if all the successor states are also part of this cycle.
\end{enumerate}
Once all steps are passed, the only remaining sub-STGs are attractors of size $N$,
because they consist of cycles that cannot be escaped.

\Maxime{Décrire brièvement l'algo ?}
Once again, for the sake of clarity,
the pseudocode for the imperative equivalent of our method is given as Algorithm \ref{alg:PH-attractor}.
However, our method (including all three steps mentioned above) has been implemented in a purely ASP fashion.
Finally, we note that this approach allows 

%Faire un algo
\begin{algorithm}[p]
	\caption{Enumeration of the attractors of size $N$ of a PH}
	\label{alg:PH-attractor}
	\begin{itemize}
		\item[] \textbf{INPUT:} A network $PH=(\PHs,\PHl,\PHa)$, an integer $N$ \quad // $N \geq 2$
		\item[] \textbf{OUTPUT:} All the attractors of size $N$
		\item[] \textbf{Initialize:} $\Delta_N \longleftarrow \varnothing$ \quad // Will be the set of the attractors of size $N$
		\item[] \textbf{Begin:} \\
		
			\hspace{0.2cm}	\textbf{\textit{forall}} $\PHst_i \in \PHl$ \textbf{\textit{do}} 
				
				\begin{itemize}
					\item[] Compute the $N$ successors: $\PHst_i \rightarrowtail ... \rightarrowtail \PHst_N$ \\ Let $\Delta_N^i=$\{$\PHst_j \in \PHl, i \leq j \leq N$\} %be the set of these states
					
					\item[] \textbf{\textit{if}} $\PHst_i = \PHst_N$ \textbf{\textit{then}} \\
						\hspace{0.7cm}  $loop(\Delta_N^i) \longleftarrow True$ \\
					 \textbf{\textit{else}} \\
					 	\hspace{0.7cm}  $loop(\Delta_N^i) \longleftarrow False$ \\
					 \textbf{\textit{end if}} 
					 
					\item[] \textbf{\textit{if}} $loop(\Delta_N^i) = True$ \textbf{\textit{then}} \\
					
%						\begin{itemize}
							\hspace{0.7cm} $attractor(\Delta_N^i) \longleftarrow True$	\\
							
							\hspace{0.7cm} \textbf{\textit{forall}} $\PHst_j \in \Delta_N^i$ \textbf{\textit{do}} \\
							
							\hspace{1.2cm} \textbf{\textit{if}} $\exists$ $\Sce(\PHst_j) \notin  \Delta_N^i$ \textbf{\textit{then}} \\ \hspace{1.7cm} $attractor(\Delta_N^i) \longleftarrow False$ \\
							\hspace{1.2cm} \textbf{\textit{end if}} 
							
							\textbf{\textit{else}} \\
							\hspace{0.7cm} $attractor(\Delta_N^i) \longleftarrow False$ \\
%						\end{itemize}		
							\textbf{\textit{end if}} 
														
					\item[] \textbf{\textit{if}} $attractor(\Delta_N^i) = True$ \textbf{\textit{then}}\\
						\hspace{0.7cm} \textbf{\textit{forall}} $\PHst_j, \PHst_k \in \Delta_N^i, j \neq k$ \textbf{\textit{do}} \\								
								\hspace{1.2cm} \textbf{\textit{if}} $loop(\Delta_k^j) = True$ \textbf{\textit{then}}\\
									\hspace{1.7cm} $complexLoop(\Delta_N^i) \longleftarrow False$ \\
									\hspace{1.7cm} $x \longleftarrow j+1$ \\									
									\hspace{1.7cm} \textbf{\textit{while}} $x \leq k-1 $ \textbf{\textit{and}} $complexLoop(\Delta_N^i) = False$ \textbf{\textit{do}} \\	
									
										\hspace{2.1cm} \textbf{\textit{if}} $loop(\Delta_{k+x}^{j+x}) = False$ \textbf{\textit{then}}\\
											\hspace{2.5cm} $complexLoop(\Delta_N^i) \longleftarrow True$ \\
										\hspace{2.1cm} \textbf{\textit{end if}} \\
									\hspace{1.7cm} \textbf{\textit{end while}} \\
								\hspace{1.2cm} \textbf{\textit{end if}} \\
						\hspace{0.7cm} \textbf{\textit{end forall}} 	\\

					\hspace{0.7cm} \textbf{\textit{if}} $complexLoop(\Delta_N^i) = False$ \textbf{\textit{then}}\\
						\hspace{1.2cm}  $attractor(\Delta_N^i) \longleftarrow False$\\
					\hspace{0.7cm} \textbf{\textit{end if}} 						
						
					\textbf{\textit{end if}} \\

					\item[] \textbf{\textit{if}} $attractor(\Delta_N^i) = True$ \textbf{\textit{then}}\\
					\hspace{0.5cm}  $\Delta_N \longleftarrow \Delta_N \cup \{ \Delta_N^i \}$ \\
					\textbf{\textit{end if}} 

				\end{itemize}		
			\hspace{0.2cm} \textbf{\textit{end forall}} \\		
			\hspace{0.2cm} \textbf{\textit{return}} $\Delta_N$		
	\end{itemize}
\end{algorithm}

% Mettre du code ASP + explication
\subsection{Cycles enumeration}
The approach that we present here first searches for all sub-graphs with a given number $N$ of transitions %(i.e path of length $N$)
in the network.
For this, we once again start from every possible initial state in the model (\refl{selectprocesses}). 

The evolution of a model is then computed within a limited number $N$ of steps. In an ASP program, it is possible to instantiate constants whose values will be defined by the user at each execution. Here, we use \texttt{n} as a constant that represents the number of states we want to consider
inside the predicate \texttt{state(0..n)}.
For example, \texttt{state(0..5)} will compute every 6 first successive states, including the initial state.

Because the dynamics of a PH is solely described by its actions, identifying the future states requires to first identify the playable actions for each state.
We recall that an action is playable in a state when all its hitter processes and target process are active in this state (see \pref{def:playableAction}).
% Therefore, we define an ASP predicate $\texttt{playable(action(A}_\texttt{1}\texttt{,I}_\texttt{1}\texttt{,...,A}_\texttt{k}\texttt{,I}_\texttt{k}\texttt{,B,J,K),S)}$ which is true when the processes  ${\texttt{A}_\texttt{1}}_{\texttt{I}_\texttt{1}}\texttt{,...,}{\texttt{A}_\texttt{k}}_{\texttt{I}_\texttt{k}}$ and $\texttt{B}_\texttt{J}$ are active at state \texttt{S}.
Therefore, we define an ASP predicate $\texttt{playable(action(A1,I1,...,Ak,Ik,B,J,K),S)}$ which is true when the processes $\texttt{A1}_{\texttt{I1}}$, ..., $\texttt{Ak}_{\texttt{Ik}}$ and $\texttt{BJ}$ are active in state \texttt{S}.

Then, all the possible evolutions of the model can be enumerated by a cardinality rule such as the one of \refl{e2a}:
this line creates a set of as many predicates as there are possible simulations from the considered initial state,
thus reproducing all possible branchings in the dynamics of the model, in the form of as many new potential answer sets.
It is also needed to enforce the strictly asynchronous dynamic
which forces that exactly one process can change between two states (thus maintaining the non-determinism).
We use the constraint of \refl{e2b} to remove all scenarios where two or more actions have been played simultaneously between two states.
Thus, the remaining scenarios contained in the answer sets all strictly follow
the asynchronous dynamics defined in \pref{sec:defs}.
We witness that the active process of a given sort \texttt{B} has changed between two consecutive states \texttt{S} and \texttt{S+1} with the predicate \texttt{change(B,S+1)} of \refll{e3a}{e3b}
depending on the chosen action to be played.
For this, it is once again necessary to duplicate this rule depending on the maximal number of hitters in all actions in the model,
as we did for the rules of \refll{constraintFix}{constraintFix2}.
Finally, all active processes of the new state of step \texttt{S+1}
are gathered into a predicate \texttt{instate}.
This predicate endorses the fact that one process has evolved (\refl{e4})
while all the processes from all the other sorts
remain identical in their condition of the previous state (\refll{e5}{e5a}).

\begin{lstlisting}
1{play(Action,S)}1 :- playable(Action,S), state(S). %\label{e2a} 
:- 2{play(Action,S)}, state(S). %\label{e2b}
change(B,S+1) :- play(action(_,_,B,_,_),T), state(S). %\label{e3a}
change(B,S+1) :- play(action(_,_,_,_,B,_,_),T), state(S). %\label{e3b}
instate(activeProc(B,K),S+1) :-  play(action(_,_,B,_,K),S), state(S).%\label{e4}
instate(activeProc(B,K),S+1) :-  instate(activeProc(B,K),S),%\label{e5}
          not change(B,S+1), state(S).%\label{e5a}
\end{lstlisting}

The overall result of the pieces of program presented in this subsection
(\refl{selectprocesses} and \refll{e2a}{e5a})
is a collection of answer sets,
with one answer for each possible simulation in $N$ time steps,
starting from any initial state.
As a result, it reproduces all sub-STG of size $N$.
%%%%%%%%%%%

Once a sub-STG is found, it remains to check whether it is a cycle (\ie a loop) or not.
To do so, we need a predicate \texttt{repeter(P,S1,S2)} (\refll{repeter1}{repeter2}) which is true for each process active in both \texttt{S1} and \texttt{S2}.
Predicate \texttt{getNbrRepetition(X,S1,S2)} (\refll{getRep1}{getRep2}) then computes the number \texttt{X} of identical active processes between two states \texttt{S1} and \texttt{S2}.
At this point, determining if there is a loop between \texttt{S1} and \texttt{S2}
only requires to compare the value \texttt{X} to the total number of sorts in the model:
if both are equal, it means that \texttt{S1} and \texttt{S2} are identical states.
In our case, we only need to compare the first (\texttt{S1=0}) and last (\texttt{S2=n}) states of each sub-STG.
We finally eliminate all sub-STG that are not cycles with the constraint of \refl{loop}.
\begin{lstlisting}
repeter(P,S1,S2) :- selectProcSt(P,S1), selectProcSt(P,S2), %\label{repeter1}
state(S1), state(S2). %\label{repeter2}
getNbrRepetition(X,S1,S2) :- X={repeter(F,S1,S2)}, S1!=S2, %\label{getRep1}
state(S1), state(S2). %\label{getRep2}
:- not loop(0, n).  %\label{loop}
\end{lstlisting}

\subsection{Attractors enumeration}
\Maxime{Tout le début de cette section n'est pas très clair et mériterait aussi d'être clarifié et reformulé.}
Since each state of the STG of an automata network has various next states (due to the non-deterministic dynamics), a cyclic sub-STG is not necessarily an attractor. Thus, we first need to determine the presence of a cycle by checking whether the first state and the last state of the sub-STG are the same. Then we check if this sub-STG is an attractor. 
Filtering the remaining sub-STGs means using a constraint in ASP. Indeed a constraint has many advanges for such NP-Hard problems. Indeed, it permits to decrease the computational time. But to benifit of this specific type of logic rules, we have to think oppositly and present the opposite of what we are looking for. 
In our case, to say that a cycle is not an attractor, it means that it has at least one state that has a successor which is not apart of it (\refl{existOut}).
\begin{lstlisting}
:- existActionOut.  %\label{existOut}
\end{lstlisting}
It is necessary now to compute all playble actions for each state $\texttt{S}_\texttt{i}$ between the states \texttt{0} and \texttt{n}. For that we propose a similar rule to \refl{e2a} but with different predicate name and different parameters: \texttt{candidatePlayable(Action,S)}. It is true when an action \texttt{Action} is playable at state \texttt{S} which is between \texttt{0} and \texttt{n}. Also this action should be different from the action that was played in the cycle transforming the system from \texttt{S} to \texttt{S+1} that is also a part of the cycle (\refll{comptPlayAct}{candidatPlayAct}).
\begin{lstlisting}
firstCandidatePlayable(action(A,I,B,J,K),S) :- action(A,I,B,J,K), %\label{comptPlayAct}
		selectProcSt(activeProc(B,J),S), selectProcSt(activeProc(A,I),S), 
		loop(0, n), S>0, S<n, state(S).		
candidatePlayable(Action1,S) :- firstCandidatePlayable(Action1,S), 
		playable(Action2,S), Action1!= Action2.	%\label{candidatPlayAct}
\end{lstlisting}
After finding the candidate playable actions in each state of the cycle, it remains to verify if the result states are already a part of the cycle or if there are new states. Indeed it is possible to have other playable actions in the cycle (\texttt{playableInCycle}, \refll{playIncyc1}{playIncyc3}) but these actions lead to the same states. It confirms that the model indefinitely cycles in these states. Once all playable actions are checked whatever they leads to a state in the cycle or not, the predicate \texttt{existActionOut} is verified when at least one action could envolve the system to a state out of the cycle (\refl{existActOut1}).
\begin{lstlisting}
playableInCycle(action(A,I,B,J,K),S) :- candidatePlayable(action(A,I,B,J,K),S), %\label{playIncyc1}
	selectProcSt(activeProc(B,K),Si), Si>=0, Si<=n, Si!=S+1, %\label{playIncyc2}
	getNbrRepetition(X,S,Si), getNbreSorts(Y), Y==X+1, state(Si). %\label{playIncyc3}
existActionOut :- candidatePlayable(Action,S), not playableInCycle(Action,S). %\label{existActOut1}
\end{lstlisting}

At this step, we want to ensure that the considered attractor is of size $N$, and not of a size which is a divisor of $N$. The idea, as described in Algorithm \ref{alg:PH-attractor} and \refll{loopX}{constraintloopX}, is to filter the repeated loops out of the result. For this, we define the predicate \texttt{loopX(S1,S2,X)} which becomes true if there is a loop between the \texttt{X}\textsuperscript{th} successor of \texttt{S1} and the \texttt{X}\textsuperscript{th} successor of \texttt{S2} in the considered succession of states. This predicate is a clue that the same loop may have been traversed twice. In \texttt{notloopX(S1,S2)} we state that there exists at least one \texttt{X}\textsuperscript{th} successor of \texttt{S1} that does not loop back to the \texttt{X}\textsuperscript{th} successor of \texttt{S2}. Finally with the constraint in \refl{constraintloopX}, we eliminate the case of having the repeated loops.

\begin{lstlisting}
loopX(S1,S2,X) :- loop(S1+X, S2+X), 0<=X, X<=S2-S1, state(S1;S2;X). %\label{loopX}
notloopX(S1,S2) :- not loopX(S1,S2,X), 0<=X, X<=S2-S1, state(S1;S2;X). %\label{notloopX}
:- loop(S1,S2), loop(S1, S2+(S2-S1)), not notloopX(S1,S2). %\label{constraintloopX}
\end{lstlisting}

The problem of finding attractors in a multi-valued automata network is NP-hard. However, we have good results when the algorithm \ref{alg:PH-attractor} is developed with ASP \Maxime{Je ne suis pas d'accord : on ne traduit pas cet algorithme en ASP ! On écrit autre chose qui doit nous donner un résultat équivalent, mais ce n'est pas un algorithme impératif}. Indeed, we show in Section \ref{sec:results}, by performing a number of computational experiments on biological networks, that the program can tackle even large systems and return a result in few seconds.

%
%
%Clearly, all states between any two occurrences of the last state belong to a loop. A loop corresponds to an attractor. We mark all attractor’s states. In the following iterations, we will only search for paths in which the last state is not marked.
%Until at least one attractor remains unmarked, we can find a path of any length since we can cycle in an attractor forever. However, once all attractors are identified and marked, we will only be able find paths which are shorter than a given length (at most the diameter of the STG). So, when we search for a path of some length k and it does not exist, this means that all attractors are already identified and the algorithm can terminate.
%If a path of length k does exist and it is loop-free, we double k and continue the search for a path of the new length.
%We illustrate the algorithm on the example of the Boolean network in Figure 1. The algorithm starts from searching for a path of length $N = 3$
